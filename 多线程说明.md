# 多线程程序说明

## 概述

本程序已升级为多线程版本，支持并行计算和线程安全操作。

## 多线程技术实现

### 1. 使用的C++11多线程特性

- **std::thread** - 创建和管理线程
- **std::async** - 异步任务执行
- **std::future** - 获取异步任务结果
- **std::mutex** - 互斥锁，保护共享资源
- **std::atomic** - 原子操作，实现线程安全的计数器
- **std::lock_guard** - RAII锁管理，自动释放锁

### 2. 并行计算功能

#### 2.1 并行计算阶乘 (parallelFactorial)
```cpp
std::vector<long long> parallelFactorial(const std::vector<int>& numbers, int threadCount = 4);
```
- 使用 `std::async` 为每个数字创建异步任务
- 所有任务并行执行
- 使用 `std::future` 收集结果

#### 2.2 并行判断质数 (parallelIsPrime)
```cpp
std::vector<bool> parallelIsPrime(const std::vector<int>& numbers, int threadCount = 4);
```
- 并行判断多个数是否为质数
- 适合处理大量数据

#### 2.3 并行计算平方 (parallelSquare)
```cpp
std::vector<double> parallelSquare(const std::vector<double>& numbers, int threadCount = 4);
```
- 并行计算多个数的平方

#### 2.4 并行执行加法 (parallelAdd)
```cpp
std::vector<double> parallelAdd(const std::vector<std::pair<double, double>>& pairs, int threadCount = 4);
```
- 并行执行多个加法运算

#### 2.5 批量并行计算 (parallelBatchCompute)
```cpp
void parallelBatchCompute(const std::vector<int>& numbers, int threadCount = 4);
```
- 使用 `std::thread` 创建多个工作线程
- 每个线程处理一部分数据
- 使用互斥锁保护输出操作

### 3. 线程安全机制

#### 3.1 原子计数器
```cpp
std::atomic<long long> callCount{0};
```
- 使用原子操作记录函数调用次数
- 无需加锁，性能高
- 线程安全

#### 3.2 互斥锁
```cpp
std::mutex mtx;  // 类成员
std::mutex printMtx;  // 保护输出
```
- 保护共享资源的访问
- 防止数据竞争

## 性能优势

### 单线程 vs 多线程

对于计算密集型任务（如阶乘、质数判断），多线程可以显著提升性能：

- **并行计算阶乘**：6个数同时计算，耗时约500-600微秒
- **并行判断质数**：8个数同时判断，耗时约500-600微秒
- **并行计算平方**：6个数同时计算，耗时约500-600微秒

相比顺序执行，多线程版本可以充分利用多核CPU，提升计算效率。

## 测试覆盖

### 多线程测试用例

1. **testParallelFactorial()** - 验证并行阶乘计算正确性
2. **testParallelIsPrime()** - 验证并行质数判断正确性
3. **testParallelSquare()** - 验证并行平方计算正确性
4. **testParallelAdd()** - 验证并行加法计算正确性
5. **testThreadSafeCounter()** - 验证线程安全计数器
   - 10个线程 × 100次调用 = 1000次总调用
   - 验证原子操作的线程安全性
6. **testConcurrentAccess()** - 并发访问压力测试
   - 8个线程同时执行不同操作
   - 验证程序在并发环境下的稳定性

## 编译要求

- C++11或更高版本
- 需要链接pthread库（已在Makefile中添加 `-pthread` 标志）

## 使用示例

```cpp
Calculator calc;

// 并行计算多个数的阶乘
std::vector<int> numbers = {5, 10, 15, 20};
std::vector<long long> results = calc.parallelFactorial(numbers, 4);

// 并行判断质数
std::vector<int> primes = {17, 19, 23, 29};
std::vector<bool> isPrimeResults = calc.parallelIsPrime(primes, 4);

// 查看函数调用统计（线程安全）
long long count = calc.getCallCount();
```

## 注意事项

1. **线程数量**：默认使用4个线程，可根据CPU核心数调整
2. **线程安全**：所有并行函数都是线程安全的
3. **异常处理**：并行函数会传播异常，需要适当处理
4. **性能考虑**：对于简单计算，线程创建开销可能大于计算本身

## 适用场景

多线程版本特别适合：
- 大量独立计算任务
- CPU密集型操作（阶乘、质数判断等）
- 需要统计函数调用次数的场景
- 需要并发处理多个请求的场景

## 技术亮点

1. ✅ 使用现代C++11多线程特性
2. ✅ 实现线程安全的计数器
3. ✅ 支持多种并行计算模式
4. ✅ 完整的测试覆盖（包括多线程测试）
5. ✅ 无编译警告，代码质量高

