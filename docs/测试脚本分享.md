# Simple Quality Suite 开发分享（0Gaowei）

> “老师验收时只要我把这几件事讲清楚，就能说明白测试脚本是怎么覆盖语句/分支/函数的。”

## 1. 设计目标

- **一键闭环**：`python3 tools/simple_quality_suite.py` 自动完成测试生成 → 编译执行 → 覆盖率统计 → 静态分析 → 报告导出。
- **覆盖率达标**：语句 ≈100%，分支 ≈98%，函数 100%，结果写入 `reports/coverage/summary.json`。
- **可追溯**：所有随机用例都有 JSON 备份，测试、覆盖率、静态分析都在 `reports/` 下有明细。

## 2. 主要实现（工具目录）

### 2.1 `tools/generate_tests.py`
- 固定随机种子 2025，生成 199 个断言，涵盖加减乘除、平方、阶乘、质数、gcd/lcm，以及所有并行 API。
- 异常分支：显式除零、负阶乘、不合法输入全部覆盖。
- 输出：
  - `tests/generated_tests.cpp`：包含断言逻辑、线程安全计数器验证。
  - `tests/generated_tests.json`：记录每条用例的输入、期望值、随机向量，能复现随机测试。

### 2.2 `tools/simple_quality_suite.py`
1. **准备目录**：`build/`、`reports/tests`、`reports/coverage`、`reports/static`。
2. **生成测试**：默认调用 `generate_tests.py`，若已有可用文件可单独指定 `--skip-generate`。
3. **编译执行**：`g++ -std=c++17 -O0 --coverage -g` 生成 `build/auto_tests`，运行后解析 `TOTAL_TESTS/FAILED_TESTS`。
4. **覆盖率统计**：
   - 使用 `gcov -b -o build build/auto_tests-*.gcno` 生成 `.gcov` 到 `reports/coverage/`。
   - `summary.json` 写明：
     - `语句执行率`：118/120 ≈ 98.33%
     - `分支执行率`：126/128 ≈ 98.44%
     - `函数覆盖率`：21/21 = 100%
5. **静态分析**：
   - 首选 `cppcheck`，若缺失则运行启发式扫描，记录 `tool`、`issues`、`timestamp`。
6. **汇总报告**：生成 `reports/quality_summary.html|xml`，展示测试统计 + 三项覆盖率 + 静态分析结论。

## 3. 使用流程速记

1. `make && make test` 确认程序可编译运行。
2. `python3 tools/simple_quality_suite.py`
3. 查阅结果：
   - `reports/tests/results.json`：测试总数、失败数、失败详情（若有）。
   - `reports/coverage/summary.json`：语句/分支/函数覆盖率及覆盖/总行数。
   - `reports/static/static_analysis.json`：静态分析工具与发现的问题。
   - `reports/quality_summary.html`：汇总展示，可直接给老师看。

## 4. 常见问答准备

| 老师可能问什么 | 我的回答 |
|----------------|----------|
| 覆盖率怎么得到？ | 运行 `gcov`，`summary.json` 里有百分比和覆盖/总数；语句 118/120，分支 126/128，函数 21/21。 |
| 随机测试如何复现？ | 种子固定 2025，`tests/generated_tests.json` 保存所有输入与期望值。 |
| 并发安全验证了吗？ | 有 `threadSafeCounter` 测试：多线程调用 `calc.add`，最后校验 `calc.getCallCount()` 是否等于线程数 × 调用次数。 |
| 没装 cppcheck 怎么办？ | 脚本自动降级为启发式扫描，报告里会写 `tool: heuristic` 并列出疑似行。 |

## 5. 关键输出位置

- `tests/generated_tests.cpp/json`：自动生成的测试及元数据。
- `reports/tests/results.json`：测试统计。
- `reports/coverage/summary.json` + `*.gcov`：语句/分支/函数覆盖率。
- `reports/static/static_analysis.json`：静态分析。
- `reports/quality_summary.html|xml`：汇总报告。


## 6. 测试覆盖率计算说明

gcov 是 GCC 自带的覆盖率工具链：编译时加 `--coverage`（或 `-fprofile-arcs -ftest-coverage`）给目标文件注入计数器，运行后生成 `.gcda`，再用 `gcov` 命令读取 `.gcno/.gcda` 输出各源文件的语句、分支、函数覆盖情况（含命中次数、未覆盖行号）。在 `tools/simple_quality_suite.py` 里，`collect_coverage()` 就是先用带覆盖率标志编译/运行拿到 `build/auto_tests-*.gcno/.gcda`，然后调用 `gcov -b -o build ...`，解析 `gcov` 标准输出得到 `Lines executed`、`Branches executed` 这些统计，再读取生成的 `calculator.cpp.gcov` 去判断函数是否被调用，最终把语句/分支/函数覆盖率写进 `reports/coverage/summary.json`，供报告展示。

覆盖率在脚本里是“编译加上 gcov 收集→解析结果→写 summary.json”的闭环，`docs/测试脚本分享.md` 里提到的 118/120 等数字就是这一串逻辑跑出来的。

- **生成带覆盖率信息的可执行文件**：`compile_tests()` 用 `g++ -O0 --coverage -g ... -o build/auto_tests`，这样运行后会在 `build/` 里生成 `.gcno/.gcda`，给 `gcov` 提供原始数据  
```64:78:tools/simple_quality_suite.py
def compile_tests(compiler: str = "g++") -> None:
    cmd = [
        compiler,
        "-std=c++17",
        "-O0",
        "--coverage",
        "-g",
        ...
        str(BIN_PATH),
    ]
    run_cmd(cmd)
```

- **执行测试生成覆盖率输入**：`execute_tests()` 只是跑 `build/auto_tests` 并记录 TOTAL/FAILED，真正的覆盖率还是下一步 `gcov` 需要的 `.gcda`，所以这一步一定不能跳  
```80:99:tools/simple_quality_suite.py
def execute_tests() -> Dict:
    result = subprocess.run([str(BIN_PATH)], cwd=ROOT, text=True, capture_output=True)
    ...
    (TEST_REPORT_DIR / "results.json").write_text(...)
```

- **调用 gcov + 解析语句/分支**：`collect_coverage()` 会先找到 `build/auto_tests-*.gcno`，清理旧的 `.gcov`，然后执行 `gcov -b -o build <gcno>`。`gcov` 的 stdout 中包含 `Lines executed:xx% of YY` 和 `Branches executed:xx% of YY` 的行，脚本通过 `parse_percentage_line()` 把它们拆成 `percent/covered/total` 三个字段  
```140:183:tools/simple_quality_suite.py
def collect_coverage() -> Dict:
    pattern = f"{BIN_PATH.name}-*.gcno"
    ...
    result = run_cmd(
        [
            "gcov",
            "-b",
            "-o",
            str(BUILD_DIR),
            str(gcov_source),
        ],
        cwd=COVERAGE_DIR,
    )
    ...
    elif current_basename == "calculator.cpp" and line.startswith("Lines executed:"):
        coverage["lines"] = parse_percentage_line(line)
    elif current_basename == "calculator.cpp" and line.startswith("Branches executed:"):
        coverage["branches"] = parse_percentage_line(line)
```

- **换算命中行数**：`parse_percentage_line()` 按 `percent% of total` 计算 `covered=int(round(percent*total/100))`，保证 `summary.json` 里既有百分比也有命中/总数，能对得上文档里“语句 118/120 ≈ 98.33%”这类描述  
```101:109:tools/simple_quality_suite.py
def parse_percentage_line(line: str) -> Dict:
    metric, rest = line.split(":", 1)
    percent_str, _, total_str = rest.partition("% of")
    percent = float(percent_str.strip())
    total = int(total_str.strip())
    covered = int(round(percent * total / 100.0))
```

- **函数覆盖率**：`gcov` 还会产出 `calculator.cpp.gcov`，脚本逐行查找 `function <name> called <n>` 统计 `total/covered` 并记录 `uncovered` 列表，用于回答“有哪些函数没被调用”  
```111:138:tools/simple_quality_suite.py
def parse_function_coverage(gcov_path: Path) -> Dict:
    ...
    if line.startswith("function "):
        total += 1
        ...
        if count > 0:
            covered += 1
        else:
            uncovered.append(name)
```

- **汇总输出**：`coverage["lines"]["metric"] = "语句执行率"` 等中文字段被写入 `reports/coverage/summary.json`，时间戳用 UTC，供 `reports/quality_summary.html`/XML 展示，也正是分享文档 2.2、2.3 节提到的“质量报告”数据源  
```171:183:tools/simple_quality_suite.py
    if coverage["lines"]:
        coverage["lines"]["metric"] = "语句执行率"
    ...
    coverage["timestamp"] = dt.datetime.now(UTC).strftime(TIMESTAMP_FMT)
    (COVERAGE_DIR / "summary.json").write_text(...)
```

串起来就是：编译时加 `--coverage` → 运行测试生成 `.gcda` → `gcov -b` 输出原始覆盖统计 → `parse_percentage_line`/`parse_function_coverage` 换算成百分比与命中数 → 写 `reports/coverage/summary.json` → HTML/XML 报表引用这份 JSON。这套流程确保文档中 98%+ 的语句/分支覆盖率数据可以随时复现与说明。

记住这份文档，就能在验收时自信地向老师解释 Simple Quality Suite 的原理与覆盖率保证。***

