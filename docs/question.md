# 一.简答题（共7 题,100.0分）

## 1
请使用等价类划分法为NextDate函数列出输入域等价类表，并设计相应的测试用例。
填写答案:

NextDate函数输入：年(year)、月(month)、日(day)

### 输入域等价类表

| 输入条件 | 有效等价类 | 编号 | 无效等价类 | 编号 |
|---------|-----------|------|-----------|------|
| 年份 | 1900-2100 | 1 | <1900 | 7 |
|      |           |     | >2100 | 8 |
| 月份 | 1-12 | 2 | <1 | 9 |
|      |      |    | >12 | 10 |
| 日期 | 1-28（所有月份） | 3 | <1 | 11 |
|      | 29（闰年2月） | 4 | >31 | 12 |
|      | 29（非闰年2月） | 5 | 30（2月） | 13 |
|      | 30（4,6,9,11月） | 6 | 31（2月） | 14 |
|      | 31（1,3,5,7,8,10,12月） | 7 | 31（4,6,9,11月） | 15 |
|      | 30（1,3,5,7,8,10,12月） | 8 | 32（1,3,5,7,8,10,12月） | 16 |

### 测试用例设计

| 用例ID | 年 | 月 | 日 | 预期输出 | 覆盖等价类 |
|--------|----|----|----|---------|-----------|
| TC1 | 2000 | 6 | 15 | 2000/6/16 | 1,2,3 |
| TC2 | 2000 | 2 | 28 | 2000/2/29 | 1,2,3（闰年2月） |
| TC3 | 2000 | 2 | 29 | 2000/3/1 | 1,2,4（闰年2月29日） |
| TC4 | 2001 | 2 | 28 | 2001/3/1 | 1,2,3（非闰年2月） |
| TC5 | 2000 | 4 | 30 | 2000/5/1 | 1,2,6（30天月份） |
| TC6 | 2000 | 1 | 31 | 2000/2/1 | 1,2,7（31天月份） |
| TC7 | 2000 | 12 | 31 | 2001/1/1 | 1,2,7（年末） |
| TC8 | 1899 | 6 | 15 | 无效输入 | 7 |
| TC9 | 2101 | 6 | 15 | 无效输入 | 8 |
| TC10 | 2000 | 0 | 15 | 无效输入 | 9 |
| TC11 | 2000 | 13 | 15 | 无效输入 | 10 |
| TC12 | 2000 | 6 | 0 | 无效输入 | 11 |
| TC13 | 2000 | 6 | 32 | 无效输入 | 12 |
| TC14 | 2000 | 2 | 30 | 无效输入 | 13 |
| TC15 | 2000 | 2 | 31 | 无效输入 | 14 |
| TC16 | 2000 | 4 | 31 | 无效输入 | 15 |

## 2

假设商店货品价格(R) 都不大于100元(且为整数)，若顾客付款(P)在100元内，现有一个程序能在每位顾客付款后给出找零钱的最佳组合(找给顾客货币张数最少)。 假定此商店的货币面值只包括:50元(N50)、10元(N10)、 5元(N5)、1元(N1) 四种。
请结合等价类划分法和边界值分析法为上述程序设计 出相应的测试用例。
填写答案:

### 等价类划分

| 输入条件 | 有效等价类 | 编号 | 无效等价类 | 编号 |
|---------|-----------|------|-----------|------|
| 价格R | 1-100（整数） | 1 | <1 | 5 |
|      |            |    | >100 | 6 |
|      |            |    | 非整数 | 7 |
| 付款P | R ≤ P ≤ 100（整数） | 2 | P < R | 8 |
|      |            |    | P > 100 | 9 |
|      |            |    | 非整数 | 10 |
| 找零金额 | P-R = 0 | 3 | - | - |
|         | P-R > 0 | 4 | - | - |

### 边界值分析

- 价格R：0, 1, 50, 99, 100, 101
- 付款P：R-1, R, R+1, 50, 99, 100, 101
- 找零金额：0, 1, 5, 10, 50, 99

### 测试用例设计

| 用例ID | 价格R | 付款P | 找零 | 预期输出（N50,N10,N5,N1） | 测试类型 |
|--------|------|------|------|-------------------------|---------|
| TC1 | 1 | 1 | 0 | (0,0,0,0) | 等价类+边界值 |
| TC2 | 1 | 2 | 1 | (0,0,0,1) | 等价类+边界值 |
| TC3 | 50 | 50 | 0 | (0,0,0,0) | 等价类 |
| TC4 | 50 | 100 | 50 | (1,0,0,0) | 等价类+边界值 |
| TC5 | 99 | 100 | 1 | (0,0,0,1) | 等价类+边界值 |
| TC6 | 100 | 100 | 0 | (0,0,0,0) | 等价类+边界值 |
| TC7 | 1 | 51 | 50 | (1,0,0,0) | 等价类 |
| TC8 | 1 | 11 | 10 | (0,1,0,0) | 等价类 |
| TC9 | 1 | 6 | 5 | (0,0,1,0) | 等价类 |
| TC10 | 1 | 4 | 3 | (0,0,0,3) | 等价类 |
| TC11 | 1 | 61 | 60 | (1,1,0,0) | 等价类（组合） |
| TC12 | 1 | 16 | 15 | (0,1,1,0) | 等价类（组合） |
| TC13 | 1 | 8 | 7 | (0,0,1,2) | 等价类（组合） |
| TC14 | 0 | 50 | - | 无效输入 | 无效等价类 |
| TC15 | 101 | 50 | - | 无效输入 | 无效等价类 |
| TC16 | 50 | 49 | - | 无效输入（P<R） | 无效等价类 |
| TC17 | 50 | 101 | - | 无效输入（P>100） | 无效等价类 |
| TC18 | 1 | 100 | 99 | (1,4,1,4) | 边界值（最大找零） |


## 3

某软件的一个模块的需求规格说明书中描述:
(1)年薪制员工:严重过失，扣年终风险金的4%;过失，扣年终风险金的2%。
(2)非年薪制员工:严重过失，扣当月薪资的8%;过失，扣当月薪资的4%。
请绘制出因果图和判定表，并给出相应的测试用例。
填写答案:

### 因果图分析

**原因（输入条件）：**
- C1: 是年薪制员工
- C2: 是严重过失
- C3: 是过失

**结果（输出）：**
- E1: 扣年终风险金的4%
- E2: 扣年终风险金的2%
- E3: 扣当月薪资的8%
- E4: 扣当月薪资的4%

**约束关系：**
- C2和C3是互斥的（不能同时为真）

### 判定表

| 规则 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|------|---|---|---|---|---|---|---|---|
| **条件** |
| C1: 年薪制员工 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| C2: 严重过失 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 |
| C3: 过失 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
| **动作** |
| E1: 扣年终风险金4% | ✓ | ✓ | - | - | - | - | - | - |
| E2: 扣年终风险金2% | - | - | ✓ | ✓ | - | - | - | - |
| E3: 扣当月薪资8% | - | - | - | - | ✓ | ✓ | - | - |
| E4: 扣当月薪资4% | - | - | - | - | - | - | ✓ | ✓ |
| **不可能情况** | ✗ | ✗ | ✗ | ✗ | ✗ | ✗ | - | - |

注：规则1-6中C2和C3不能同时为真，但判定表中列出所有组合以便分析。

### 简化判定表（去除不可能情况）

| 规则 | 1 | 2 | 3 | 4 |
|------|---|---|---|---|
| **条件** |
| C1: 年薪制员工 | 1 | 1 | 0 | 0 |
| C2: 严重过失 | 1 | 0 | 1 | 0 |
| C3: 过失 | 0 | 1 | 0 | 1 |
| **动作** |
| E1: 扣年终风险金4% | ✓ | - | - | - |
| E2: 扣年终风险金2% | - | ✓ | - | - |
| E3: 扣当月薪资8% | - | - | ✓ | - |
| E4: 扣当月薪资4% | - | - | - | ✓ |

### 测试用例

| 用例ID | 员工类型 | 过失类型 | 预期结果 | 覆盖规则 |
|--------|---------|---------|---------|---------|
| TC1 | 年薪制 | 严重过失 | 扣年终风险金的4% | 规则1 |
| TC2 | 年薪制 | 过失 | 扣年终风险金的2% | 规则2 |
| TC3 | 非年薪制 | 严重过失 | 扣当月薪资的8% | 规则3 |
| TC4 | 非年薪制 | 过失 | 扣当月薪资的4% | 规则4 |
| TC5 | 年薪制 | 无过失 | 不扣款 | 边界情况 |
| TC6 | 非年薪制 | 无过失 | 不扣款 | 边界情况 |


## 4

某城市电话号码由三部分组成，分别是:
地区码—— 空白或三位数字;
前 缀—— 非‘0’或‘1’开头的三位数字;
后 缀—— 4位数字。
假定被测程序能接受一切符合上述规定的电话号码， 拒绝所有不符合规定的电话号码。要求:
(1)请选择适当的黑盒测试方法，写出选择该方法的原因，并使用该方法的步骤，给出测试用例表。
(2)如果所生成的测试用例不够全面，请考虑用别的测试 方法生成一些补充的测试用例。
填写答案:

### (1) 选择等价类划分法

**选择原因：**
- 输入域有明确的规则和约束条件
- 可以清晰地划分有效等价类和无效等价类
- 适合处理格式化的输入（电话号码）
- 能够系统性地覆盖所有可能的输入情况

**等价类划分步骤：**
1. 分析输入条件，确定等价类
2. 为每个等价类编号
3. 设计测试用例，覆盖有效和无效等价类

### 等价类划分表

| 输入条件 | 有效等价类 | 编号 | 无效等价类 | 编号 |
|---------|-----------|------|-----------|------|
| 地区码 | 空白 | 1 | 非空白非三位数字 | 5 |
|        | 三位数字（000-999） | 2 | 少于三位数字 | 6 |
|        |           |    | 多于三位数字 | 7 |
|        |           |    | 包含非数字字符 | 8 |
| 前缀 | 2-9开头的三位数字 | 3 | 0开头的三位数字 | 9 |
|      |           |    | 1开头的三位数字 | 10 |
|      |           |    | 少于三位数字 | 11 |
|      |           |    | 多于三位数字 | 12 |
|      |           |    | 包含非数字字符 | 13 |
| 后缀 | 4位数字（0000-9999） | 4 | 少于4位数字 | 14 |
|      |           |    | 多于4位数字 | 15 |
|      |           |    | 包含非数字字符 | 16 |

### 测试用例表（等价类划分法）

| 用例ID | 地区码 | 前缀 | 后缀 | 预期结果 | 覆盖等价类 |
|--------|--------|------|------|---------|-----------|
| TC1 | 空白 | 234 | 5678 | 接受 | 1,3,4 |
| TC2 | 010 | 234 | 5678 | 接受 | 2,3,4 |
| TC3 | 999 | 234 | 5678 | 接受 | 2,3,4 |
| TC4 | 空白 | 234 | 0000 | 接受 | 1,3,4（边界） |
| TC5 | 空白 | 234 | 9999 | 接受 | 1,3,4（边界） |
| TC6 | 空白 | 234 | 1234 | 接受 | 1,3,4 |
| TC7 | 空白 | 999 | 5678 | 接受 | 1,3,4（前缀边界） |
| TC8 | 空白 | 200 | 5678 | 接受 | 1,3,4（前缀边界） |
| TC9 | 01 | 234 | 5678 | 拒绝 | 6 |
| TC10 | 0123 | 234 | 5678 | 拒绝 | 7 |
| TC11 | 01A | 234 | 5678 | 拒绝 | 8 |
| TC12 | 空白 | 034 | 5678 | 拒绝 | 9 |
| TC13 | 空白 | 134 | 5678 | 拒绝 | 10 |
| TC14 | 空白 | 23 | 5678 | 拒绝 | 11 |
| TC15 | 空白 | 2345 | 5678 | 拒绝 | 12 |
| TC16 | 空白 | 23A | 5678 | 拒绝 | 13 |
| TC17 | 空白 | 234 | 567 | 拒绝 | 14 |
| TC18 | 空白 | 234 | 56789 | 拒绝 | 15 |
| TC19 | 空白 | 234 | 567A | 拒绝 | 16 |

### (2) 补充测试用例（边界值分析法）

**选择原因：**
- 等价类划分可能遗漏边界值情况
- 电话号码格式有明确的长度限制
- 需要测试边界值和临界值

**补充测试用例：**

| 用例ID | 地区码 | 前缀 | 后缀 | 预期结果 | 测试类型 |
|--------|--------|------|------|---------|---------|
| TC20 | 空白 | 200 | 0000 | 接受 | 边界值（前缀最小，后缀最小） |
| TC21 | 空白 | 999 | 9999 | 接受 | 边界值（前缀最大，后缀最大） |
| TC22 | 000 | 234 | 5678 | 接受 | 边界值（地区码最小） |
| TC23 | 999 | 234 | 5678 | 接受 | 边界值（地区码最大） |
| TC24 | 空白 | 201 | 5678 | 接受 | 边界值（前缀接近最小值） |
| TC25 | 空白 | 998 | 5678 | 接受 | 边界值（前缀接近最大值） |
| TC26 | 空白 | 234 | 0001 | 接受 | 边界值（后缀接近最小值） |
| TC27 | 空白 | 234 | 9998 | 接受 | 边界值（后缀接近最大值） |

### 补充测试用例（错误推测法）

| 用例ID | 地区码 | 前缀 | 后缀 | 预期结果 | 测试类型 |
|--------|--------|------|------|---------|---------|
| TC28 | null | 234 | 5678 | 拒绝 | 错误推测（空指针） |
| TC29 | 空白 | null | 5678 | 拒绝 | 错误推测（空指针） |
| TC30 | 空白 | 234 | null | 拒绝 | 错误推测（空指针） |
| TC31 | "   " | 234 | 5678 | 拒绝 | 错误推测（空格字符串） |
| TC32 | 空白 | -234 | 5678 | 拒绝 | 错误推测（负数） |
| TC33 | 空白 | 234 | -5678 | 拒绝 | 错误推测（负数） |


## 5

使用基本路径测试方法，为以下程序段设计测试用例。

```cpp
void Do (int X,int A,int B)
{
1 if ( (A>1)&&(B=0) )
2 X = X/A;
3 if ( (A=2)||(X>1) )
4 X = X+1;
5 }
```

填写答案:

### 程序流程图分析

```
开始
  ↓
节点1: if (A>1 && B==0)
  ├─是→ 节点2: X = X/A
  └─否→ (跳过节点2)
  ↓
节点3: if (A==2 || X>1)
  ├─是→ 节点4: X = X+1
  └─否→ (跳过节点4)
  ↓
节点5: 结束
```

### 控制流图

```
    开始
      ↓
    [节点1: A>1 && B==0]
      ↓
    [节点2: X = X/A]
      ↓
    [节点3: A==2 || X>1]
      ↓
    [节点4: X = X+1]
      ↓
      结束
```

### 独立路径识别

1. **路径1**: 1→3→5 (A≤1 或 B≠0, A≠2 且 X≤1)
2. **路径2**: 1→2→3→5 (A>1 且 B=0, A≠2 且 X≤1)
3. **路径3**: 1→3→4→5 (A≤1 或 B≠0, A=2 或 X>1)
4. **路径4**: 1→2→3→4→5 (A>1 且 B=0, A=2 或 X>1)

### 圈复杂度计算

V(G) = 边数 - 节点数 + 2 = 6 - 5 + 2 = 3
或
V(G) = 判定节点数 + 1 = 2 + 1 = 3

需要至少3条独立路径（加上基本路径共4条）。

### 测试用例设计

| 用例ID | 输入 | 预期输出 | 覆盖路径 | 说明 |
|--------|------|---------|---------|------|
|        | X | A | B | X | A | B |      |      |
| TC1 | 2 | 0 | 1 | 2 | 0 | 1 | 路径1 | A≤1, A≠2, X≤1 |
| TC2 | 3 | 2 | 0 | 2 | 2 | 0 | 路径2 | A>1且B=0, X/A=1, A=2 |
| TC3 | 3 | 1 | 1 | 4 | 1 | 1 | 路径3 | A≤1, X>1 |
| TC4 | 4 | 2 | 0 | 3 | 2 | 0 | 路径4 | A>1且B=0, X/A=2, A=2 |

### 详细路径分析

**路径1**: 1→3→5
- 条件1: A>1 && B==0 为假
- 条件2: A==2 || X>1 为假
- 测试用例: X=2, A=0, B=1
  - A>1 && B==0 = false (A=0)
  - A==2 || X>1 = false (A=0, X=2)
  - 结果: X=2 (不变)

**路径2**: 1→2→3→5
- 条件1: A>1 && B==0 为真 → 执行X=X/A
- 条件2: A==2 || X>1 为假
- 测试用例: X=3, A=2, B=0
  - A>1 && B==0 = true → X=3/2=1 (整数除法)
  - A==2 || X>1 = true (A=2)
  - 注意：实际会执行路径4，需要调整

**路径2修正**: X=2, A=3, B=0
  - A>1 && B==0 = true → X=2/3=0 (整数除法)
  - A==2 || X>1 = false (A=3, X=0)
  - 结果: X=0

**路径3**: 1→3→4→5
- 条件1: A>1 && B==0 为假
- 条件2: A==2 || X>1 为真
- 测试用例: X=3, A=1, B=1
  - A>1 && B==0 = false
  - A==2 || X>1 = true (X=3>1)
  - 结果: X=4

**路径4**: 1→2→3→4→5
- 条件1: A>1 && B==0 为真 → 执行X=X/A
- 条件2: A==2 || X>1 为真
- 测试用例: X=4, A=2, B=0
  - A>1 && B==0 = true → X=4/2=2
  - A==2 || X>1 = true (A=2)
  - 结果: X=3

### 最终测试用例表

| 用例ID | X | A | B | 执行路径 | 预期X | 说明 |
|--------|---|---|---|---------|-------|------|
| TC1 | 2 | 0 | 1 | 1→3→5 | 2 | 跳过两个if |
| TC2 | 2 | 3 | 0 | 1→2→3→5 | 0 | 执行X/A，不执行X+1 |
| TC3 | 3 | 1 | 1 | 1→3→4→5 | 4 | 不执行X/A，执行X+1 |
| TC4 | 4 | 2 | 0 | 1→2→3→4→5 | 3 | 执行X/A和X+1 |

## 6

在三角形问题中，要求输入三个边长:a，b，c。当三边不可能构成三角形时提示错误，可构成三角形时计算三角形的周长。若是等腰三角形打印"等腰三角形"，若是等边三角形，则打印"等边三角形"。画出相应的程序流程图，并采用基本路径测试方法为该程序设计测试用例。
填写答案:

### 程序流程图

```
开始
  ↓
输入 a, b, c
  ↓
判断: a+b>c && a+c>b && b+c>a && a>0 && b>0 && c>0
  ├─否→ 输出"错误：不能构成三角形"
  │      ↓
  │    结束
  │
  └─是→ 计算周长 = a+b+c
         ↓
        判断: a==b && b==c
         ├─是→ 输出"等边三角形"，周长
         │      ↓
         │    结束
         │
         └─否→ 判断: a==b || a==c || b==c
                ├─是→ 输出"等腰三角形"，周长
                │      ↓
                │    结束
                │
                └─否→ 输出"一般三角形"，周长
                       ↓
                      结束
```

### 控制流图

```
    开始
      ↓
    [输入a,b,c]
      ↓
    [判断: 能否构成三角形]
      ├─否→ [输出错误] → 结束
      └─是→ [计算周长]
              ↓
            [判断: a==b && b==c]
              ├─是→ [输出等边三角形] → 结束
              └─否→ [判断: a==b || a==c || b==c]
                      ├─是→ [输出等腰三角形] → 结束
                      └─否→ [输出一般三角形] → 结束
```

### 独立路径识别

1. **路径1**: 开始→输入→判断三角形(否)→输出错误→结束
2. **路径2**: 开始→输入→判断三角形(是)→计算周长→判断等边(是)→输出等边→结束
3. **路径3**: 开始→输入→判断三角形(是)→计算周长→判断等边(否)→判断等腰(是)→输出等腰→结束
4. **路径4**: 开始→输入→判断三角形(是)→计算周长→判断等边(否)→判断等腰(否)→输出一般→结束

### 圈复杂度计算

V(G) = 判定节点数 + 1 = 3 + 1 = 4
需要至少4条独立路径。

### 基本路径测试用例

| 用例ID | 输入 | 预期输出 | 覆盖路径 | 说明 |
|--------|------|---------|---------|------|
|        | a | b | c |      |      |      |
| TC1 | 1 | 2 | 5 | 错误：不能构成三角形 | 路径1 | 1+2<5，不能构成三角形 |
| TC2 | 3 | 3 | 3 | 等边三角形，周长=9 | 路径2 | 等边三角形 |
| TC3 | 3 | 3 | 4 | 等腰三角形，周长=10 | 路径3 | 等腰三角形(a==b) |
| TC4 | 3 | 4 | 5 | 一般三角形，周长=12 | 路径4 | 一般三角形 |

### 详细测试用例设计

| 用例ID | a | b | c | 预期输出 | 覆盖路径 | 测试目的 |
|--------|---|---|---|---------|---------|---------|
| TC1 | 1 | 2 | 5 | 错误：不能构成三角形 | 路径1 | 不能构成三角形（a+b≤c） |
| TC2 | 1 | 5 | 2 | 错误：不能构成三角形 | 路径1 | 不能构成三角形（a+c≤b） |
| TC3 | 5 | 1 | 2 | 错误：不能构成三角形 | 路径1 | 不能构成三角形（b+c≤a） |
| TC4 | 0 | 3 | 4 | 错误：不能构成三角形 | 路径1 | 边长≤0 |
| TC5 | -1 | 3 | 4 | 错误：不能构成三角形 | 路径1 | 边长<0 |
| TC6 | 3 | 3 | 3 | 等边三角形，周长=9 | 路径2 | 等边三角形 |
| TC7 | 3 | 3 | 4 | 等腰三角形，周长=10 | 路径3 | 等腰三角形(a==b) |
| TC8 | 3 | 4 | 3 | 等腰三角形，周长=10 | 路径3 | 等腰三角形(a==c) |
| TC9 | 4 | 3 | 3 | 等腰三角形，周长=10 | 路径3 | 等腰三角形(b==c) |
| TC10 | 3 | 4 | 5 | 一般三角形，周长=12 | 路径4 | 一般三角形 |
| TC11 | 5 | 12 | 13 | 一般三角形，周长=30 | 路径4 | 一般三角形（直角三角形） |

### 边界值测试用例

| 用例ID | a | b | c | 预期输出 | 测试目的 |
|--------|---|---|---|---------|---------|
| TC12 | 1 | 1 | 1 | 等边三角形，周长=3 | 最小等边三角形 |
| TC13 | 1 | 1 | 2 | 错误：不能构成三角形 | 边界值（1+1=2） |
| TC14 | 1 | 2 | 2 | 等腰三角形，周长=5 | 边界值（1+2>2） |
| TC15 | 100 | 100 | 100 | 等边三角形，周长=300 | 较大等边三角形 |


## 7

某程序所画出的N-S图如图所示的，至少需要多少个测试用例才能对该程序实现逻辑覆盖?
![NS图](./NS图.png)


填写答案:

### N-S图逻辑覆盖分析

由于无法直接查看图片，根据常见的N-S图结构和逻辑覆盖要求，分析如下：

### 逻辑覆盖类型

1. **语句覆盖（Statement Coverage）**：每条语句至少执行一次
2. **判定覆盖（Decision Coverage）**：每个判定的真假分支至少执行一次
3. **条件覆盖（Condition Coverage）**：每个条件的真假值至少取一次
4. **判定/条件覆盖**：同时满足判定覆盖和条件覆盖
5. **条件组合覆盖**：每个判定中所有条件的各种可能组合至少出现一次
6. **路径覆盖（Path Coverage）**：每条可能的路径至少执行一次

### 一般N-S图结构分析

典型的N-S图通常包含：
- 顺序结构
- 选择结构（if-else）
- 循环结构（while/for）

### 最少测试用例数计算

**对于基本路径覆盖（最常用）：**
- 需要覆盖所有独立路径
- 圈复杂度 V(G) = 判定节点数 + 1
- 最少测试用例数 = 圈复杂度

**对于判定覆盖：**
- 每个判定需要2个测试用例（真、假）
- 最少测试用例数 = 判定节点数

**对于条件覆盖：**
- 每个条件需要2个测试用例
- 最少测试用例数取决于条件的组合数

### 假设N-S图包含以下结构：

如果N-S图包含：
- 1个if判定 → 最少2个测试用例（真、假）
- 2个if判定 → 最少2-4个测试用例（取决于嵌套关系）
- 1个if-else → 最少2个测试用例
- 嵌套if → 最少2^n个测试用例（n为嵌套层数）

### 答案（通用分析）

**对于逻辑覆盖（判定覆盖），至少需要：**

```
最少测试用例数 = 判定节点数

如果N-S图中有：
- 1个判定节点 → 至少2个测试用例
- 2个判定节点 → 至少2个测试用例（如果独立）或4个（如果嵌套）
- 3个判定节点 → 至少2-8个测试用例（取决于结构）

对于基本路径覆盖：
最少测试用例数 = 圈复杂度 V(G) = 判定节点数 + 1
```

### 具体答案（需要根据实际N-S图）

**请根据实际N-S图结构确定：**

1. **统计判定节点数**：数出N-S图中所有的判断框（菱形）
2. **计算圈复杂度**：V(G) = 判定节点数 + 1
3. **最少测试用例数**：
   - 判定覆盖：判定节点数（每个判定需要真、假各一次，但可以合并）
   - 基本路径覆盖：圈复杂度值
   - 条件组合覆盖：2^n（n为条件数）

**示例：**
- 如果N-S图有2个独立的if判定 → 至少2个测试用例
- 如果N-S图有2个嵌套的if判定 → 至少4个测试用例
- 如果N-S图有1个if-else → 至少2个测试用例

**建议答案格式：**
```
根据N-S图结构，该程序包含X个判定节点，圈复杂度为V(G)=X+1。

对于逻辑覆盖（判定覆盖），至少需要X个测试用例。
对于基本路径覆盖，至少需要X+1个测试用例。
对于条件组合覆盖，至少需要2^Y个测试用例（Y为条件总数）。
```
